name: Claude Code Review

on:
  pull_request:
    types: [opened, synchronize, ready_for_review, reopened]
    paths:
      - "src/**/*.py"
      - "tests/**/*.py"
      - "pyproject.toml"

jobs:
  claude-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: read
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Run Claude Code Review
        id: claude-review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt: |
            Review PR #${{ github.event.pull_request.number }} in ${{ github.repository }}.

            ## Review Philosophy: Invert, Always Invert

            Apply Charlie Munger's inversion principle: Instead of asking "Is this code good?",
            ask "What would make this code fail?"

            Focus on preventing failure:
            - What edge cases would break this?
            - What would cause this to fail in production?
            - What would make this unmaintainable in 6 months?
            - What security holes does this open?

            When something could fail, explain HOW it would fail and suggest prevention.

            ## Project Context: pcp-mcp

            MCP server for Performance Co-Pilot (PCP). Python 3.10+, FastMCP 2.0+.

            Tech Stack:
            - MCP Framework: FastMCP 2.0+
            - HTTP Client: httpx (async)
            - Backend: pmproxy REST API
            - Type checking: ty (NOT pyright or mypy)
            - Linting/Formatting: ruff
            - Testing: pytest + pytest-asyncio + respx
            - Package manager: uv

            ## Inversion Checklists by File Type

            ### Source Code (src/pcp_mcp/**/*.py)

            MCP server failures to prevent:
            - Tools not returning proper Pydantic response models
            - Not handling httpx exceptions (must convert to ToolError)
            - Blocking calls in async tool functions
            - Missing type hints or docstrings
            - Rate calculation errors (counter vs gauge metrics)

            FastMCP patterns to enforce:
            - Tools use @mcp.tool() decorator with proper type hints
            - Resources use @mcp.resource() decorator
            - Context accessed via ctx.request_context.lifespan_context
            - Errors raised as ToolError or ResourceError

            ### Client (src/pcp_mcp/client.py)

            What would cause the client to fail?
            - Not creating pmapi context on __aenter__
            - Not closing httpx client on __aexit__
            - Rate calculation with wrong elapsed time
            - Not handling counter wrap-around
            - Timeout not respected

            ### Tools (src/pcp_mcp/tools/**/*.py)

            What would cause tools to fail?
            - Exceptions not mapped to ToolError via handle_pcp_error()
            - Missing Annotated[type, Field(...)] for parameter descriptions
            - sample_interval too short for accurate rates
            - Not awaiting async calls

            ### Resources (src/pcp_mcp/resources/**/*.py)

            What would cause resources to fail?
            - Resources attempting write operations (they're read-only!)
            - Resource URI patterns not matching expected format
            - Not handling missing metrics gracefully

            ### Tests (tests/**/*.py)

            What would make these tests meaningless?
            - Tests that pass but don't assert meaningful outcomes
            - Mocks without spec= (won't catch attribute errors)
            - Missing edge cases: empty responses, network errors, invalid data
            - Not testing both success and failure paths
            - Not using respx for httpx mocking

            ### Anti-Patterns to Flag

            CRITICAL - Counter metrics are CUMULATIVE (since boot), NOT per-second rates:
            - kernel.all.cpu.*
            - disk.all.read_bytes, disk.all.write_bytes
            - network.interface.in.bytes, network.interface.out.bytes
            - proc.psinfo.utime, proc.psinfo.stime

            DO NOT query with query_metrics() expecting rates.
            USE get_system_snapshot() or get_process_top() instead.

            Other anti-patterns:
            - NEVER use empty except: blocks
            - ALWAYS wrap exceptions with handle_pcp_error()
            - ALWAYS return Pydantic models from tools
            - ALWAYS use Annotated[type, Field(...)] for tool params

            ## What NOT to Review

            Don't nitpick these - automated tools handle them:
            - Style issues: ruff handles formatting and linting
            - Type errors: ty handles type checking
            - Import order: ruff's isort handles this

            Focus review time on logic, architecture, and failure modes.

